export const dictionary = [
  // Common verbs
  "be",
  "have",
  "do",
  "say",
  "get",
  "make",
  "go",
  "know",
  "take",
  "see",
  "come",
  "think",
  "look",
  "want",
  "give",
  "use",
  "find",
  "tell",
  "ask",
  "seem",
  "feel",
  "try",
  "leave",
  "call",
  "need",
  "become",
  "put",
  "mean",

  // Common nouns
  "time",
  "year",
  "people",
  "way",
  "day",
  "man",
  "thing",
  "woman",
  "life",
  "child",
  "world",
  "school",
  "state",
  "family",
  "student",
  "group",
  "country",
  "problem",
  "hand",
  "part",
  "place",
  "case",
  "week",
  "company",
  "system",
  "question",
  "work",
  "number",
  "point",
  "government",
  "home",

  // Common adjectives
  "good",
  "new",
  "first",
  "last",
  "long",
  "great",
  "little",
  "own",
  "other",
  "old",
  "right",
  "big",
  "high",
  "different",
  "small",
  "large",
  "next",
  "early",
  "young",
  "important",
  "few",
  "public",
  "bad",
  "same",
  "able",

  // Common adverbs
  "well",
  "only",
  "then",
  "there",
  "when",
  "where",
  "why",
  "again",
  "still",
  "never",
  "always",
  "sometimes",
  "often",
  "usually",
  "really",
  "almost",

  // Prepositions
  "about",
  "above",
  "across",
  "after",
  "against",
  "along",
  "among",
  "around",
  "at",
  "before",
  "behind",
  "below",
  "beneath",
  "beside",
  "between",
  "beyond",
  "by",
  "down",
  "during",
  "except",
  "for",
  "from",
  "in",
  "inside",
  "into",

  // Articles and pronouns
  "the",
  "a",
  "an",
  "this",
  "that",
  "these",
  "those",
  "my",
  "your",
  "his",
  "her",
  "its",
  "our",
  "their",
  "who",
  "which",
  "what",
  "whose",
  "whom",

  // Numbers and time
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "hundred",
  "thousand",
  "million",
  "billion",
  "today",
  "tomorrow",
  "yesterday",
  "month",
  "hour",
  "minute",
  "second",
  "morning",

  // Technology terms
  "computer",
  "internet",
  "software",
  "hardware",
  "program",
  "data",
  "file",
  "network",
  "website",
  "email",
  "browser",
  "server",
  "code",
  "digital",
  "algorithm",
  "application",
  "database",
  "security",
  "virtual",
  "cloud",

  // Business terms
  "business",
  "market",
  "product",
  "service",
  "customer",
  "client",
  "employee",
  "manager",
  "meeting",
  "project",
  "report",
  "sales",
  "cost",
  "price",
  "value",
  "quality",
  "strategy",
  "growth",
  "development",
  "plan",

  // Academic terms
  "research",
  "study",
  "theory",
  "analysis",
  "method",
  "result",
  "conclusion",
  "evidence",
  "experiment",
  "hypothesis",
  "science",
  "education",
  "knowledge",
  "learning",
  "teaching",
  "professor",
  "course",
  "class",
  "degree",
  "thesis",

  // Common phrases
  "thank",
  "please",
  "welcome",
  "hello",
  "goodbye",
  "sorry",
  "excuse",
  "help",
  "like",
  "love",
  "hate",
  "understand",
  "begin",
  "start",
  "finish",

  // Spell checker specific
  "spell",
  "check",
  "checker",
  "correct",
  "correction",
  "mistake",
  "error",
  "word",
  "text",
  "edit",
  "editing",
  "grammar",
  "vocabulary",
  "dictionary",
  "suggestion",
  "alternative",
  "replace",
  "replacement",
  "change",
  "modify",

  // Levenshtein specific
  "levenshtein",
  "distance",
  "matrix",
  "calculation",
  "minimum",
  "operation",
  "operations",
  "insert",
  "delete",
  "substitute",
  "character",
  "string",
  "compare",
  "comparison",
  "similarity",
  "difference",
];

export function levenshteinDistance(
  a: string,
  b: string
): {
  distance: number;
  matrix: number[][];
} {
  const matrix: number[][] = [];

  for (let i = 0; i <= a.length; i++) {
    matrix[i] = [i];
  }

  for (let j = 0; j <= b.length; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      if (a[i - 1] === b[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1)
        );
      }
    }
  }

  return {
    distance: matrix[a.length][b.length],
    matrix: matrix,
  };
}

export function findSuggestions(word: string, maxDistance: number = 3) {
  return dictionary
    .map((dictWord) => ({
      word: dictWord,
      ...levenshteinDistance(word.toLowerCase(), dictWord.toLowerCase()),
    }))
    .filter((result) => result.distance <= maxDistance)
    .sort((a, b) => a.distance - b.distance);
}
